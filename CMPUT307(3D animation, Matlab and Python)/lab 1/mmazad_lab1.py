###########################
# DO NOT MODIFY THIS PART #
# BUT YOU SHOULD READ IT  #
###########################
import heapq


class Node:
    """
    Huffman tree node definition.
    """
    def __init__(self, symbol=None, count=0, left=None, right=None):
        """
        initialization
          symbol   : symbol to be coded
          count    : count of symbol
          left     : left child node
          right    : right child node
        """
        self.__left = left
        self.__right = right
        self.__symbol = symbol
        self.__count = count
        self.__code_word = ''

    def setLeft(self, l):
        """
        sets the left child of current node
        """
        self.__left = l
    
    def setRight(self, r):
        """
        sets the right child of current node
        """
        self.__right = r
    
    def getLeft(self):
        """
        returns the left child of current node
        """
        return self.__left
    
    def getRight(self):
        """
        returns the right child of current node
        """
        return self.__right

    def setSymbol(self, symbol):
        """
        sets coding symbol of current node
        """
        self.__symbol = symbol

    def getSymbol(self):
        """
        returns coding symbol of current node
        """
        return self.__symbol

    def setCount(self, count):
        """
        sets count of the symbol
        """
        self.__count = count

    def getCount(self):
        """
        returns count of the symbol
        """
        return self.__count
    
    def setCodeWord(self, code_word):
        """
        sets code-word of the symbol
        """
        self.__code_word = code_word

    def getCodeWord(self):
        """
        returns code-word of the symbol
        """
        return self.__code_word

    def __lt__(self, node):
        return self.__count < node.getCount()

    def __repr__(self):
        return "symbol: {}, count: {}, code-word: {}".format(self.__symbol, self.__count, self.__code_word)

###########################
# DO NOT MODIFY THIS PART #
# BUT YOU SHOULD READ IT  #
###########################

#############################
# YOUR OWN HELPER FUNCTIONS #
#############################
codeTable = {} #a table to store codewords for each symbol

def clearCodeTable(): #clears the codeword table
    codeTable.clear()

def createCodeTable(root_node):#recursively looks through the binary tree and 
    
    if (root_node.getSymbol() != None):
        codeTable[root_node.getSymbol()] = root_node.getCodeWord()

    if ((root_node.getLeft() == None) and (root_node.getRight() == None)): #check if this is a leaf node
        leafNode = True

    while not leafNode: #as long as this is not a leaf node, keep looking through the tree and save codes
        if ((root_node.getLeft() != None)):
            createCodeTable(root_node.getLeft())
        if ((root_node.getRight() != None)):
            createCodeTable(root_node.getRight())

    return codeTable
#############################
# YOUR OWN HELPER FUNCTIONS #
#############################

##############################
# FINISH THE BELOW FUNCTIONS #
##############################
def buildDictionary(message):
    """
    counts the occurrence of every symbol in the message and store it in a python dictionary
      parameter:
        message: input message string
      return:
        python dictionary, key = symbol, value = occurrence
    """
    characterTable = {}                         #create an empty dictionary
    
    message = str(message)                      #ensure the message is in a string format

    for char in message:                        #iterate through the message and add the character plus it's count to dictionary 
        if char in characterTable:
            characterTable[char] += 1
        else:
            characterTable[char] = 1
    
    return characterTable                       #Return created dictionary

def buildHuffmanTree(word_dict):
    """
    uses the word dictionary to generate a huffman tree using a min heap
      parameter:
        word_dict  : word dictionary generated by buildDictionary()
      return:
        root node of the huffman tree
    """
    huffmanTree = []

    #append every key/value pair into the array
    for sym, count in word_dict.items():
        node = Node(sym, count)
        heapq.heappush(huffmanTree, node)
    
    #as long as we don't have a single root node, extract two nodes, create a new internal node and return to tree
    while (len(huffmanTree) > 1):
        
        #extract smallest two nodes
        node_1 = heapq.heappop(huffmanTree)
        node_2 = heapq.heappop(huffmanTree)
        
        #combine into new internal node and add back into the tree
        internal_node = Node(None, (node_1.getCount() + node_2.getCount()), node_1, node_2)
        heapq.heappush(huffmanTree, internal_node)

    return heapq.heappop(huffmanTree)

def assignCodeWord(root, code_word=''):
    """
    recursively assigns code-word to the nodes in the huffman tree
      parameter:
        root       : root node of the huffman tree
        code_word  : code-word for the root node
      return:
        no return
    """

    #each time we go left on the tree a '0' will be added, and each time we go right a '1' will be added
    left = code_word + '0'
    right = code_word + '1'
    leafNode = False

    #assign codewords only if the node has a symbol, also create appropriate codewords for what a left or a right child would have
    if (root.getSymbol() != None):
        root.setCodeWord(code_word)
        
    if ((root.getLeft() == None) and (root.getRight() == None)): #check if this is a leaf node
        leafNode = True

    while not leafNode: #as long as this is not a leaf node, recursively call assignCodeWord on left and right children
        if ((root.getLeft() != None)):
            assignCodeWord(root.getLeft(), left)
        if ((root.getRight() != None)):
            assignCodeWord(root.getRight(), right)

def huffmanEncode(message):
    """
    converts the input message into huffman code
      parameter:
        message    : input message string
      return:
        a tuple, the first element is the huffman code string for the input message,
        the second element is the huffman tree root node
    """
    freqTable = buildDictionary(message) 

    rootN = buildHuffmanTree(freqTable)

    if (freqTable.len() == 1):
        assignCodeWord(rootN, '0')
    
    assignCodeWord(rootN)

    clearCodeTable()
    codeList = createCodeTable(rootN) #get a code word table for the various symbols

    encodedM = ''

    for char in message:
        encodedM + codeList[char] #looks up the code word for this character and encodes accordingly

    infoTuple = (encodedM, rootN)
    return infoTuple

def huffmanDecode(message, huffman_tree):
    """
    decode the message
      parameter:
        message      : input huffman code string
        huffman_tree : huffman tree root node
      return:
        decoded message
    """
    codeList = createCodeTable(huffman_tree) #get a code word table for the various symbols
    reversedTable = {}

    #reverse the dictoionary so that the codes are the keys and the symbols are the values
    for sym, code in codeList.items():
        reversedTable[code] = sym

    decodedMessage = ''
    checkCode = ''
    for bit in message:  #for every 0 or 1 in the encoded message, try to form codewords by taking them one by one and forming a string
        checkCode += bit
        if(checkCode in reversedTable):  #if there is a matching codeword in the table, print the matching symbol
            decodedMessage += reversedTable[checkCode]
            checkCode = ''               #clear the found code so that the next code can be started
    
    return decodedMessage

def main():
    """
    main process goes here
    """

    message = input("please input a message: ")
    encodedMessage = huffmanEncode(message)

    print(encodedMessage[0])
    print (len(encodedMessage[0]))

    decodedMessage = huffmanDecode(encodedMessage[0], encodedMessage[1])

    print(decodedMessage)


##############################
# FINISH THE ABOVE FUNCTIONS #
##############################


###########################
# DO NOT MODIFY THIS PART #
###########################
if __name__ == "__main__":
    main()
###########################
# DO NOT MODIFY THIS PART #
###########################